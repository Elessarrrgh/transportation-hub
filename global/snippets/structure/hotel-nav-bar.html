<!-- Removes header and pagination from gallery content (hotel) pages -->
<style>
  .header, #footer-sections { 
    display:none !important;
  }
  .item-pagination {
    display:none !important;
  }
</style>

<!-- Ensures that navbar only appears on hotel pages -->
<script>
  document.addEventListener('DOMContentLoaded', ()=>document.body.classList.add('hotel-page'));
</script>

<!-- Persistent header: toolbar (back + title) + scroller nav -->
<header id="hotel-header" role="banner" aria-label="Hotel navigation header">
  <div class="hotel-toolbar">
    <button class="back-btn" type="button" aria-label="Go back">
      <!-- Inline SVG so it works everywhere -->
      <svg viewBox="0 0 24 24" width="22" height="22" aria-hidden="true">
        <path d="M15.5 19.5L8 12l7.5-7.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      <span class="back-label">Back</span>
    </button>
    <div class="hotel-title" aria-live="polite" aria-atomic="true"></div>
    <!-- spacer to balance flex layout -->
    <div class="toolbar-spacer" aria-hidden="true"></div>
  </div>

  <nav id="hotel-nav" aria-label="Section navigation">
    <ul>
      <li>
        <a href="#shuttle">
          <img
            src="https://images.squarespace-cdn.com/content/602b1e3b9f10401f2e609ddb/bbff25a9-f8f6-48fd-9971-82c83a84fa63/bus-icon.png?content-type=image%2Fpng" 
            alt=""
            class="nav-icon" aria-hidden="true">
          <span>Shuttle Info</span>
        </a>
      </li>
      <li>
        <a href="#stop">
          <img
            src="https://images.squarespace-cdn.com/content/602b1e3b9f10401f2e609ddb/4851a3bd-f70a-4025-8b61-1abf053be1dc/shuttle-stop-bus-icon.png?content-type=image%2Fpng" 
            alt=""
            class="nav-icon" aria-hidden="true">
          <span>Stop Info</span>
        </a>
      </li>
      <li>
        <a href="#schedule">
          <img
            src="https://images.squarespace-cdn.com/content/602b1e3b9f10401f2e609ddb/0a8ab806-7ef5-4f6f-a844-50dd9d6513e2/schedule-icon.png?content-type=image%2Fpng" 
            alt=""
            class="nav-icon" aria-hidden="true">
          <span>Schedule</span>
        </a>
      </li>
      <li>
        <a href="#hotel">
          <img
            src="https://images.squarespace-cdn.com/content/602b1e3b9f10401f2e609ddb/48812ef1-55ab-47ab-8810-278cdb3a7b56/hotel-icon.png?content-type=image%2Fpng" 
            alt=""
            class="nav-icon" aria-hidden="true">
          <span>Hotel Info</span>
        </a>
      </li>
      <li>
        <a href="#help">
          <img
            src="https://images.squarespace-cdn.com/content/602b1e3b9f10401f2e609ddb/8cb25285-b9e4-4ba3-9c3e-c6fc5bac327b/help-icon.png?content-type=image%2Fpng" 
            alt=""
            class="nav-icon" aria-hidden="true">
          <span>Help</span>
        </a>
      </li>
    </ul>
  </nav>
</header>

<style>
:root {
  --toolbar-h: 44px;     /* height of the top mini bar */
  --nav-h: 60px;         /* height of the scroller nav */
  --header-shadow: 0 1px 0 rgba(0,0,0,.06), 0 4px 12px rgba(0,0,0,.04);
  --border: #e6e6e6;
  --bg: #fff;
  --text: #222;
  --muted: #666;
  --brand: #0077cc;
  --brand-contrast: #fff;
}

/* Smooth native scrolling + offset so anchors stop below the fixed header */
html {
  scroll-behavior: smooth;
  scroll-padding-top: calc(var(--toolbar-h) + var(--nav-h) + 8px);
}

/* Reserve space so content never hides beneath the fixed header */
body {
  padding-top: calc(var(--toolbar-h) + var(--nav-h));
}

/* Fixed header container */
#hotel-header {
  position: fixed;
  top: 0; left: 0; right: 0;
  background: var(--bg);
  z-index: 9999;
  box-shadow: var(--header-shadow);
}

/* Toolbar row */
.hotel-toolbar {
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  height: var(--toolbar-h);
  padding: 0 8px;
  border-bottom: 1px solid var(--border);
}

/* Back button */
.back-btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 8px;
  background: transparent;
  border: 0;
  color: var(--text);
  cursor: pointer;
  border-radius: 8px;
}

.back-btn:focus-visible {
  outline: 2px solid var(--brand);
  outline-offset: 2px;
}

.back-btn:hover { background: rgba(0,0,0,.04); }

.back-label {
  font-size: 13px;
  color: var(--muted);
}

/* Center title */
.hotel-title {
  text-align: center;
  font-weight: 600;
  font-size: 15px;
  color: var(--text);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0 6px;
}

/* spacer matches back button width to keep title centered visually */
.toolbar-spacer { width: 56px; }

/* Nav row */
#hotel-nav {
  height: var(--nav-h);
  background: var(--bg);
}

#hotel-nav ul {
  display: flex;
  align-items: center;
  justify-content: center;
  scroll-snap-type: x proximity;
  gap: 4px;
  overflow-x: auto;
  margin: 0;
  padding: 6px 8px;
  list-style: none;
  scrollbar-width: none;
  -webkit-overflow-scrolling: touch;
}
#hotel-nav ul::-webkit-scrollbar { display: none; }

#hotel-nav li {
  flex: 0 0 auto;
  scroll-snap-align: center;
}

#hotel-nav a {
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  text-decoration: none;
  color: var(--text);
  font-weight: 500;
  font-size: 12px;
  padding: 6px 10px;
  border-radius: 10px;
}

#hotel-nav a:focus-visible {
  outline: 2px solid var(--brand);
  outline-offset: 2px;
}

#hotel-nav a.active {
  background: var(--brand);
  color: var(--brand-contrast);
}

#hotel-nav .nav-icon {
  width: 18px;
  height: 18px;
  display: block;
}

/* Ensure sections account for fixed header when using CSS-only jumps */
section[id] { scroll-margin-top: calc(var(--toolbar-h) + var(--nav-h) + 8px); }

/* Respect motion preferences for any subtle animations you add later */
@media (prefers-reduced-motion: reduce) {
  html { scroll-behavior: auto; }
}
</style>

<script>
document.addEventListener("DOMContentLoaded", () => {
  /* ---------- Back button behavior ---------- */
  const backBtn = document.querySelector(".back-btn");
  const fallbackURL = "/transportation";
  if (backBtn) {
    backBtn.addEventListener("click", () => {
      if (window.history.length > 1) history.back();
      else window.location.href = fallbackURL;
    });
  }

  /* ---------- Title auto-detect (Squarespace-friendly) ---------- */
  const titleEl = document.querySelector(".hotel-title");
  if (titleEl) {
    const candidates = [
      '[data-content-field="title"]',
      '.BlogItem-title',
      '.Entry-title',
      'h1[itemprop="headline"]',
      'h1[data-collection-title]',
      'h1'
    ];
    let titleText = "";
    for (const sel of candidates) {
      const n = document.querySelector(sel);
      if (n && n.textContent.trim()) { titleText = n.textContent.trim(); break; }
    }
    if (!titleText) {
      const docTitle = document.title || "";
      const cleaned = docTitle.split(/\s[—–|•]\s/)[0].trim();
      titleText = cleaned || "Hotel";
    }
    titleEl.textContent = titleText;
  }

  /* ---------- Collect nav links + targets ---------- */
  const navLinks = Array.from(document.querySelectorAll("#hotel-nav a[href^='#']"));
  if (!navLinks.length) return;

  const sections = navLinks
    .map(link => {
      const id = link.getAttribute("href");
      const el = document.querySelector(id);
      return el ? { id, el, link } : null;
    })
    .filter(Boolean);

  /* ---------- Header offset helpers ---------- */
  const getHeaderOffset = () => {
    const cs = getComputedStyle(document.documentElement);
    const toolbarH = parseFloat(cs.getPropertyValue('--toolbar-h')) || 44;
    const navH     = parseFloat(cs.getPropertyValue('--nav-h')) || 44;
    return Math.round(toolbarH + navH);
  };

  /* ---------- Ensure body padding matches real header height ---------- */
  const setBodyPadding = () => {
    const header = document.getElementById("hotel-header");
    if (!header) return;
    const h = header.getBoundingClientRect().height;
    document.body.style.paddingTop = `${Math.ceil(h)}px`;
    document.documentElement.style.scrollPaddingTop = `${Math.ceil(h) + 8}px`;
    document.querySelectorAll("section[id]").forEach(sec => {
      sec.style.scrollMarginTop = `${Math.ceil(h) + 8}px`;
    });
  };

  setBodyPadding();
  window.addEventListener("resize", setBodyPadding);

  /* ---------- ACTIVE LINK HIGHLIGHTING (midpoint range method) ---------- */
  // Arrays aligned by index: ids[i], tops[i], mids[i] between i and i+1
  let ids = [];     // ["#schedule", "#hotel", ...]
  let tops = [];    // [number] section tops adjusted by header offset
  let mids = [];    // [number] midpoints between consecutive tops

  const measure = () => {
    const headerOffset = getHeaderOffset();
    const data = sections.map(({ id, el }) => ({
      id,
      top: Math.floor(el.getBoundingClientRect().top + window.pageYOffset - headerOffset)
    })).sort((a,b) => a.top - b.top);

    ids  = data.map(d => d.id);
    tops = data.map(d => d.top);

    mids = [];
    for (let i = 0; i < tops.length - 1; i++) {
      mids.push((tops[i] + tops[i+1]) / 2);
    }
  };

  const setActive = (id) => {
    navLinks.forEach(a => a.classList.toggle("active", a.getAttribute("href") === id));
  };

  /* ---------- Pin logic to avoid flicker during programmatic scroll ---------- */
  let pinId = null;                // href like "#schedule" while pinned
  let pinTargetTop = null;         // absolute Y destination during the smooth scroll
  let pinUntil = 0;                // timestamp (ms) when we auto-unpin if needed

  const near = (a, b, eps = 4) => Math.abs(a - b) <= eps;
  const now  = () => performance.now();

  const pinActive = (id, targetTop, ms = 1200) => {
    pinId = id;
    pinTargetTop = targetTop;
    pinUntil = now() + ms;
    setActive(id);
  };
  const unpinActive = () => {
    pinId = null;
    pinTargetTop = null;
    pinUntil = 0;
  };

  // If the user intervenes, unpin immediately
  ['wheel','touchstart','keydown','mousedown'].forEach(evt => {
    window.addEventListener(evt, unpinActive, { passive: true });
  });

  // If supported, clear pin at the end of smooth scroll
  if ('onscrollend' in window) {
    window.addEventListener('scrollend', unpinActive);
  }

  let ticking = false;
  const onScroll = () => {
    if (ticking) return;
    ticking = true;
    requestAnimationFrame(() => {
      // If pinned, keep the clicked item active during the smooth scroll,
      // but release once we're near the destination or the timeout passes.
      if (pinId) {
        const y = window.pageYOffset;
        if ((pinTargetTop != null && near(y, pinTargetTop, 6)) || now() > pinUntil) {
          unpinActive();
        } else {
          setActive(pinId);
          ticking = false;
          return;
        }
      }

      if (!ids.length) { ticking = false; return; }
      const y = window.pageYOffset;

      // Determine which range y falls into:
      // (-∞..mids[0]) -> 0, [mids[0]..mids[1]) -> 1, ..., [mids[n-2]..+∞) -> n-1
      let idx = 0;
      while (idx < mids.length && y >= mids[idx]) idx++;

      setActive(ids[idx]);
      ticking = false;
    });
  };

  // Intercept clicks: smooth scroll ourselves and pin to avoid flicker
  navLinks.forEach(a => {
    a.addEventListener("click", (e) => {
      const id = a.getAttribute("href");
      const target = document.querySelector(id);
      if (!target) return;

      e.preventDefault(); // avoid native hash jump (which can fight our timing)

      const headerOffset = getHeaderOffset();
      const targetTop = Math.floor(target.getBoundingClientRect().top + window.pageYOffset - headerOffset);

      // Pin the clicked link as active during the smooth scroll
      pinActive(id, targetTop);

      // Programmatic smooth scroll to the adjusted top
      window.scrollTo({ top: targetTop, behavior: 'smooth' });
    });
  });

  // Initial measure + listeners
  measure();
  onScroll();
  window.addEventListener("scroll", onScroll, { passive: true });
  window.addEventListener("resize", () => { measure(); onScroll(); });

  // Recompute after lazy content settles
  window.addEventListener("load", () => { setBodyPadding(); measure(); onScroll(); });

  // Expose a hook for dynamic content changes (e.g., accordions opening)
  window.remeasureNavSpy = () => { setBodyPadding(); measure(); onScroll(); };

  // Optional: auto-remeasure when common accordion containers change
  const accRoot = document.querySelector('.accordion-container')?.parentElement || document.body;
  const mo = new MutationObserver(() => { measure(); onScroll(); });
  mo.observe(accRoot, { subtree: true, attributes: true, attributeFilter: ['class', 'style'] });
});
</script>
